PYTANIA I TODO:

Kodzik bardzo ladny jak tak pacze 

1. konstruktory mosnter i citizen, czemu konstruktory na zdefiniowane parametry, a nie a'la variadic typenames
template <typename T, typename... args>
Monster(T health, T attackPower, args ...) potem nic nie zmieniasz

Ad1 : Chyba powinno być ok, tak jak teraz wstawilem (na forum jest odpowiedz, ze to nie jest jednak variadic template - mogli jednak to wyjasnic w tresci bo skladnia jest bardzo dwuznaczna). Czyli po prostu dodalem 
typename = typename std::enable_if<std::is_arithmetic<T>::value, T>::type>
przy template'ach Monster i Citizen (napisalem test test_notArithmeticType()
w monster_test.cc ktory nie kompiluje sie dla niearytmetyczncyh typow) 

2. _health = std::max<T>(_health - damage, 0);
jak beda nie porownywalne to sie wysypie przy comipile time czy run time? musi przy compile time

Ad2 : Chyba punkt 1. zalatwia sprawe (mozna sie dopytac) bo nawet jezeli jako 
damage wywolamy jakis typ arytmetyczny, to kompilator musi znac konwersje na T,
wiec wywali sie w czasie kompilacji (przynajmniej na vector<int> i int* przy próbie konwersji do int tak to dziala)

3. z tym valueType to pytanie warte forum, jaka reprezentacje powinniśmy trzymac
ale patrzac przez pryzmat zwracania w miescie to string bedzie sponio moim zdaniem

Ad3 : Ta tuple'a w ktorej wypisujemy valueType to jedyne miejsce w ktorym z tego korzystamy w calym zadaniu wiec przyjalem ze mozna to reprezentowac jako string - dopytalbym sie w pon cwiczeniowca czy to dobre rozwiazanie.

4. co do kontenera to vector podstawowo? (czy cos innego miales na mysli)
no i jeśli vector to możemy spisac mieszkancow przy intializer list
jak nie to jedyne co znalazlem to rekturencyjnie sobie wybierac po jednym mieszkancu :D

Ad 4:
Nie za bardzo wiem jak to powinno wygladac, w sensie póki co nie mam pomyslu jak reprezentowac tych mieszkancow. Z vector<Citizen> jest taki problem, ze jezli zrobimy {Sheriff s(); Citizen c = s(); Zombie z(); attack(z,c);} to wywola sie metoda attack na zwyklym mieszkancu a nie na szeryfie. Trzeba jakos trzymac informacje o typie, ale nie za bardzo wiem jak to zrobic poki co - mozesz pomyslec, ja pewnie dopiero w sobote sie do tego z powrotem zabiore, bo pt mam raczej zawalony :P

5. chyba nie do konca rozumiem zasade działania zegara miastowego
mamy t0 ktory idzie sobie na podstawie timeStep,
jeśli trafi na aktualna liczbe fibbonaciego to potwor atakuje
jak nie to idze sobie dalej czas o timeStep nowy o ile nie przekroczy t1,
jak przekroczy t1 to t0 sie zeruje i zacykla


Ad 5:
To jest chyba tak, ze zegar sobie dziala (mod t1), zaczynajac od t0 i jezeli aktualny czas (mod t1) = Fibb(i) to jest atak.
